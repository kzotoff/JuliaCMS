<?php //>/** * Simple storage utility * version 0.15.04.14 * * @package @Registry *//*************************************************************************************************************************1. Init registry or get existing instance	$R = Registry::GetInstance();	2. Set value:	Registry::Set('index', 'value'); // global call	$R::Set('index', 'value');       // see note	$R['index'] = 'value';           // most short wayNOTE: here and below, shortand call method while being used inside a function, requires either	global $R;	or	$R = Registry::GetInstance(); // will return instance created earlier (if was)3. Get value:	echo Registry::Get('index');	echo $R::Get('index');	echo $R['index']4. Release value to free some mem:	Registry::Clean('this_large_object');	$R::Clean('this_large_object');5. View entire storage:	Registry::Dump();	$R::Dump('<br />'); // rows will be separated with line-break	$R::Dump(); // PHP_EOL (usually CR+LF) will be used by default*************************************************************************************************************************/final class Registry implements ArrayAccess {		/**	 * registry instance	 *	 * @name $instance	 */	private static $instance;	/**	 * storage array, yeah	 * @name $storage	 */	private static $storage = array();	/**	 * create if not yet	 * @return Registry	 */	public static function GetInstance() {		if (empty(self::$instance)) {			self::$instance = new self();		}		return self::$instance;	}	/**	 * Sets registry value with given index.	 *	 * @param mixed $name	 * @param mixed $value	 * @return mixed	 */	public static function Set($name, $value) {		self::$storage[$name] = $value;		return $value;	}		/**	 * Returns registry value with the given index. If not exists, exception is thrown	 *	 * @param mixed $name	 * @return mixed|false	 */	public static function Get($name) {		if (isset(self::$storage[$name])) {			return self::$storage[$name];		}		throw new Exception('Registry: no storage element "'.$name.'"');		return false;	}	/**	 * Releases registry element with the given index	 *	 * @param mixed $name	 * @return	 */	public static function Clean($name) {		unset(self::$storage[$name]);		return true;	}		/**	 * Returns all registry elements as a single string, delimited with $delimiter	 *	 * @param string $delimiter	 * @return string	 */	public static function Dump($delimiter = PHP_EOL) {		$txt = '';		foreach(self::$storage as $name => $value) {			$txt .= ($txt > '' ? $delimiter : '').$name.' = '.print_r($value, 1);		}		return $txt;	}		/**	 * Checks if registry element exists	 *	 * @param mixed $name	 * @return bool	 */	public function offsetExists($name) {		return isset(self::$storage[$name]);	}	/**	 * Wrapper for Registry->Get	 *	 * @param mixed $name	 * @return mixed	 */	public function offsetGet($name) {		return self::Get($name);	}	/**	 * Wrapper for Registry->Set	 *	 * @param mixed $name	 * @param mixed $value	 * @return mixed	 */	public function offsetSet($name, $value) {		return self::Set($name, $value);	}		/**	 * Wrapper for Registry->Clean	 *	 * @param mixed $name	 * @return true	 */	public function offsetUnset($name) {		return self::Clean($name);	}}?>